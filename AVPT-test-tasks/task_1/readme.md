### 1. Алгоритм решения Задачи №1 - Чтение
	1. Определяем точку отсчета младший бит в буффере будет находиться в крайней правой позиции, по индексу стартового бита определяем "символ буффера", в котором находится младший бит искомого значения.
	
> 	Тип возвращаемого значения (short) 16-ти битный, буду отталкиваться от того, 
> что значение длины (len) не будет превышать 16.
 >
>	Значит в лучшем случае необходимо рассмотреть один символ буффера (char - 8 бит), когда вся
> последовательность бит умещается в один символ. А в худшем случае 3 символа, когда искомый начальный бит
> находится не в начале символа буффера при длине (len) более 9 бит.
 >

	2. Количество бит (len) и стартовый бит (start) позволяет определить какое количество символов необходимо интерпритировать в число short. Остаток от деления на 8 стартового бита (start%8) показывает его позицию относительно символа буффера. Т.о начальный символ будет иметь индекс start/8 с конца буффера, а конечный (start+len)/8 если (start+len)%8 == 0, в противном случае (start+len)/8+1 с конца последовательности.
	
	3. Чтобы получить последовательность бит из этих значений необходимо наложить "маску" зануляющую все биты до искомого стартового (start%8), результат сдвинуть вправо на (start%8) сделав его стартовым битом в новом значении. После сдвига занулить лишние старшие биты с бита (8-start%8) до старшего бита.
	
	4. Если длина искомого значения больше (8-start%8) то переходим в следующий символ получаем необходимые биты таким же способом, что и в пункте 3.
	
	5. Выполняем проверку старшего бита (в новом числе он будет соответствовать длине len) если он равен 1, то зануляем его и возвращаем значение со знаком '-'.
	
#### Прототип функции:
```short getdata(char *buf, int start, int len);```
	
### 1. Алгоритм решения Задачи №1 - Запись
	1. Определяем точку отсчета.
	
	2. Выполняем обратное наложение, найденные биты в буффере зануляем, и накладываем на них биты записываемого числа.
	
	3. При обратной вставке отрицательного числа занулить его старший бит и установить значение 1 на бит соответствующий длине len.
	
> 	Буду отталкиваться от того, что запись возможна только в пределах буффера и не выходит за его границы,
> т.е без учета добавления в буффер новых элементов, т.к в этом случае прийдется сдвигать буффер на 1-2 символа,
> и добавлять новые символы в начало буффера.
 >
 
#### Прототип функции:
```void putdata(char *buf, int start, int len, short value);```
